### ğŸ— **TP : Conception dâ€™une Architecture Serverless AWS pour "Any Company Online"**  

**Objectif :** Concevoir et implÃ©menter une solution AWS **scalable**, **Ã©conomique** et **rÃ©siliente** pour une entreprise en ligne fictive. Vous utiliserez des services AWS serverless et des architectures Ã©vÃ©nementielles.

---

## **ğŸ”¹ Partie 1 : Analyse des Besoins**
### **1.1 Customer #1 - Any Company Online**
"Any Company Online" est une entreprise de commerce Ã©lectronique qui vend des produits numÃ©riques et physiques. Elle veut migrer son infrastructure vers AWS en adoptant une approche **serverless** pour bÃ©nÃ©ficier de lâ€™**Ã©volutivitÃ© automatique**, de la **rÃ©duction des coÃ»ts** et dâ€™une **gestion simplifiÃ©e**.

### **1.2 Besoins Fonctionnels**
- HÃ©berger une API REST pour gÃ©rer les commandes.
- Stocker les informations sur les produits et les commandes.
- GÃ©rer les notifications client (e-mail, SMS, push).
- Assurer une haute disponibilitÃ© et une faible latence.

### **1.3 Contraintes Techniques**
âœ… **ScalabilitÃ© automatique** (serveurs et bases de donnÃ©es doivent sâ€™adapter Ã  la charge).  
âœ… **CoÃ»t optimisÃ©** (paiement Ã  lâ€™usage avec des services serverless).  
âœ… **DÃ©couplage des composants** (Ã©viter un point unique de dÃ©faillance).  
âœ… **SÃ©curitÃ©** (contrÃ´le des accÃ¨s via IAM, encryption des donnÃ©es).

---

## **ğŸ”¹ Partie 2 : Architecture de la Solution**
### **2.1 Services AWS SÃ©lectionnÃ©s**
| **FonctionnalitÃ©** | **Service AWS** | **Pourquoi ce choix ?** |
|-------------------|---------------|--------------------|
| HÃ©bergement API | **AWS Lambda + API Gateway** | Serverless, auto-scaling, paiement Ã  lâ€™usage |
| Base de donnÃ©es | **DynamoDB** | NoSQL performant, entiÃ¨rement managÃ© |
| Notifications | **SNS** | Envoi de notifications multi-canal (email, SMS, push) |
| Gestion des files dâ€™attente | **SQS** | DÃ©couplage des services pour une meilleure rÃ©silience |
| Stockage de fichiers | **Amazon S3** | Stockage Ã©volutif et sÃ©curisÃ© |

### **2.2 SchÃ©ma de l'Architecture**  
ğŸ“Œ **Workflow** :
1. Un client passe une commande via **API Gateway**.
2. Une **AWS Lambda** est dÃ©clenchÃ©e pour valider et traiter la commande.
3. Les donnÃ©es de commande sont stockÃ©es dans **DynamoDB**.
4. Un Ã©vÃ©nement est envoyÃ© Ã  **SNS** pour notifier le client.
5. Un message est ajoutÃ© Ã  une file **SQS** pour traitement diffÃ©rÃ© (ex. : logistique).

---

## **ğŸ”¹ Partie 3 : ImplÃ©mentation Technique**
### **3.1 DÃ©ploiement des Composants AWS**
#### ğŸš€ **1ï¸âƒ£ CrÃ©ation dâ€™une Fonction Lambda**
1. Ouvrir la console AWS et aller dans **Lambda**.
2. CrÃ©er une nouvelle fonction **"ProcessOrder"**.
3. Choisir **Python 3.9** comme runtime.
4. Ajouter le code suivant :

```python
import json
import boto3
import os

dynamodb = boto3.resource('dynamodb')
sns = boto3.client('sns')

TABLE_NAME = os.environ['DYNAMODB_TABLE']
TOPIC_ARN = os.environ['SNS_TOPIC']

def lambda_handler(event, context):
    order_data = json.loads(event['body'])
    
    # Enregistrer la commande dans DynamoDB
    table = dynamodb.Table(TABLE_NAME)
    table.put_item(Item=order_data)
    
    # Envoyer une notification SNS
    message = f"Nouvelle commande reÃ§ue: {order_data['order_id']}"
    sns.publish(TopicArn=TOPIC_ARN, Message=message)
    
    return {
        'statusCode': 200,
        'body': json.dumps({'message': 'Commande traitÃ©e avec succÃ¨s!'})
    }
```

âœ… **Explication** :
- Enregistre une commande dans **DynamoDB**.
- Envoie une notification via **SNS**.
- Renvoie une rÃ©ponse HTTP 200.

#### ğŸš€ **2ï¸âƒ£ CrÃ©ation de la Table DynamoDB**
1. Aller sur **DynamoDB > CrÃ©er une table**.
2. Nom de la table : **Orders**.
3. ClÃ© primaire : **order_id** (String).
4. Activer **on-demand capacity** pour une meilleure scalabilitÃ©.

#### ğŸš€ **3ï¸âƒ£ Configuration de SNS**
1. Aller sur **SNS > CrÃ©er un sujet**.
2. Nommer le sujet : **OrderNotifications**.
3. Copier l'**ARN du sujet** et lâ€™ajouter aux **variables dâ€™environnement** de Lambda.

#### ğŸš€ **4ï¸âƒ£ CrÃ©ation de la File SQS**
1. Aller sur **SQS > CrÃ©er une file**.
2. Nom : **OrderProcessingQueue**.
3. Type : **Standard Queue**.
4. Configurer **Lambda pour ajouter des messages** Ã  cette file.

---

## **ğŸ”¹ Partie 4 : Test et Validation**
### **4.1 Test de lâ€™API avec Postman**
1. DÃ©ployer **API Gateway** pour exposer Lambda via HTTP.
2. Effectuer une requÃªte POST :

```json
{
    "order_id": "12345",
    "product": "Laptop",
    "price": 999.99
}
```

ğŸ¯ **Attendu** :  
- La commande est stockÃ©e dans DynamoDB.
- Une notification est envoyÃ©e via SNS.
- Un message est ajoutÃ© dans la file SQS.

### **4.2 Monitoring et Logs**
- **CloudWatch Logs** : VÃ©rifier les logs Lambda.
- **DynamoDB** : VÃ©rifier si la commande est bien enregistrÃ©e.
- **SNS** : VÃ©rifier la rÃ©ception des notifications.

---

## **ğŸ”¹ Partie 5 : Optimisations et Challenge**
### **5.1 AmÃ©liorations possibles**
âœ… **SÃ©curitÃ©** : Ajouter **IAM Role** pour restreindre les accÃ¨s.  
âœ… **Performance** : Activer **DynamoDB Streams** pour synchroniser les commandes en temps rÃ©el.  
âœ… **CoÃ»t** : Utiliser **S3 Glacier** pour archiver les commandes aprÃ¨s 6 mois.  

### **5.2 Challenge : Construire un POC**
ğŸ”¹ **DÃ©fi** : Ajouter une fonctionnalitÃ© qui envoie une **confirmation de commande** par e-mail via **SES (Simple Email Service)**.

ğŸš€ **Bonus :**  
- Modifier Lambda pour appeler SES.  
- Configurer SES en mode sandbox et tester avec une adresse e-mail validÃ©e.  
- Tester le systÃ¨me de bout en bout.

---

## **ğŸ”¹ Ã‰valuation Finale (Assessment 1)**
### **CritÃ¨res de Validation**
| CritÃ¨re | VÃ©rification |
|---------|-------------|
| API Gateway fonctionne | âœ… L'API rÃ©pond aux requÃªtes HTTP |
| Lambda exÃ©cute bien le traitement | âœ… Logs CloudWatch OK |
| DynamoDB stocke les commandes | âœ… Table Orders remplie |
| SNS envoie les notifications | âœ… Notification reÃ§ue par e-mail/SMS |
| SQS reÃ§oit les messages | âœ… Message dans la file dâ€™attente |

### **ğŸ¯ Score Final**
- ğŸŸ¢ **100% : Solution complÃ¨te et fonctionnelle**.
- ğŸŸ¡ **80% : API fonctionne mais manque des composants**.
- ğŸ”´ **50% et moins : Besoin de corrections importantes**.

---

## **ğŸš€ Conclusion**
ğŸ‰ FÃ©licitations ! Vous avez conÃ§u une **architecture AWS serverless** robuste pour une entreprise en ligne.

### **ğŸ’¡ Prochaine Ã‰tape :**
âœ… DÃ©ployer un front-end React pour interagir avec lâ€™API.  
âœ… IntÃ©grer une **base de donnÃ©es relationnelle** (ex: RDS) pour une gestion avancÃ©e des commandes.  
âœ… Ã‰tudier **AWS Well-Architected Framework** pour affiner votre architecture.
